<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SVG-3D Agentic System - Autonomous 3D Agent Tools</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #03050a; font-family: 'Inter', 'Segoe UI', monospace; overflow: hidden; color: #e0f0ff; }
        .agent-workspace { display: grid; grid-template-columns: 360px 1fr 360px; grid-template-rows: 1fr 280px; height: 100vh; gap: 2px; background: rgba(0,20,40,0.9); }
        .agent-control { grid-row: 1 / span 2; background: rgba(5, 15, 25, 0.98); backdrop-filter: blur(10px); border-right: 1px solid rgba(0, 255, 200, 0.3); display: flex; flex-direction: column; overflow: hidden; box-shadow: 5px 0 30px rgba(0,0,0,0.8); z-index: 20; }
        .agent-status { background: linear-gradient(135deg, #001a1a, #001010); padding: 25px; border-bottom: 1px solid #00ccaa; position: relative; overflow: hidden; }
        .agent-status::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px; background: linear-gradient(90deg, #00ffaa, #00aaff, #ff00aa, #00ffaa); animation: scanline 3s linear infinite; }
        @keyframes scanline { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
        .agent-avatar { width: 60px; height: 60px; background: rgba(0,255,200,0.1); border: 2px solid #00ffc8; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-bottom: 15px; box-shadow: 0 0 30px rgba(0,255,200,0.3); }
        .agent-name { font-size: 20px; font-weight: bold; color: #00ffc8; text-shadow: 0 0 15px rgba(0,255,200,0.5); letter-spacing: 3px; }
        .agent-state { font-size: 14px; color: #a0f0ff; margin-top: 5px; font-family: monospace; }
        .agent-toolbelt { flex: 1; overflow-y: auto; padding: 20px; }
        .tool-category { margin-bottom: 25px; background: rgba(20, 40, 60, 0.4); border-radius: 12px; padding: 15px; border: 1px solid rgba(0,255,200,0.2); }
        .tool-category h4 { color: #00ffc8; font-size: 13px; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; display: flex; align-items: center; gap: 8px; }
        .tool-button { width: 100%; background: rgba(0,255,200,0.05); border: 1px solid rgba(0,255,200,0.3); color: #e0f0ff; padding: 12px; border-radius: 8px; margin-bottom: 8px; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: all 0.2s; font-size: 13px; }
        .tool-button:hover { background: rgba(0,255,200,0.15); border-color: #00ffc8; transform: translateX(5px); box-shadow: -5px 5px 20px rgba(0,255,200,0.2); }
        .viewport-3d { position: relative; background: #000408; overflow: hidden; border-bottom: 1px solid rgba(0,255,200,0.2); }
        #svg3dCanvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 960px; height: 720px; background: radial-gradient(circle at 50% 50%, #0a1a2a, #000000); border-radius: 16px; box-shadow: 0 0 60px rgba(0,255,200,0.15); border: 1px solid rgba(0,255,200,0.3); }
        .agent-overlay { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: none; z-index: 30; }
        .perception-panel, .reasoning-panel { background: rgba(0,20,30,0.85); backdrop-filter: blur(5px); border-radius: 12px; padding: 15px; width: 280px; font-family: monospace; font-size: 12px; pointer-events: auto; }
        .perception-panel { border: 1px solid #00ffc8; color: #00ffc8; }
        .reasoning-panel { border: 1px solid #ffaa00; color: #ffaa00; }
        .action-log { position: absolute; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); border: 1px solid #00ffc8; border-radius: 12px; padding: 15px; max-height: 120px; overflow-y: auto; font-family: monospace; font-size: 12px; color: #a0f0ff; z-index: 40; }
        .log-entry { margin-bottom: 5px; border-left: 3px solid #00ffc8; padding-left: 10px; }
        .agent-memory { background: rgba(5, 15, 25, 0.98); backdrop-filter: blur(10px); border-left: 1px solid rgba(0, 255, 200, 0.3); overflow: hidden; display: flex; flex-direction: column; }
        .memory-header { padding: 20px; border-bottom: 1px solid #00ccaa; display: flex; justify-content: space-between; align-items: center; }
        .memory-graph { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
        .memory-node { background: rgba(0,255,200,0.05); border: 1px solid rgba(0,255,200,0.3); border-radius: 8px; padding: 12px; font-size: 12px; transition: all 0.3s; }
        .memory-node:hover { border-color: #00ffc8; background: rgba(0,255,200,0.1); transform: translateX(-5px); }
        .memory-time { color: #00ffc8; font-size: 10px; margin-bottom: 5px; }
        .agent-command { grid-column: 2 / span 2; background: rgba(5, 15, 25, 0.98); border-top: 1px solid rgba(0, 255, 200, 0.3); display: flex; align-items: center; padding: 0 25px; gap: 20px; }
        .command-input { flex: 1; background: rgba(0,0,0,0.5); border: 1px solid #00ffc8; border-radius: 30px; padding: 15px 25px; color: #00ffc8; font-family: monospace; font-size: 14px; outline: none; }
        .command-input:focus { box-shadow: 0 0 20px rgba(0,255,200,0.3); background: rgba(0,20,30,0.8); }
        .agent-thinking { display: flex; gap: 5px; color: #ffaa00; }
        .dot-flashing { width: 8px; height: 8px; background: #00ffc8; border-radius: 50%; animation: dotFlashing 1s infinite linear; }
        @keyframes dotFlashing { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
    </style>
</head>
<body>
<div class="agent-workspace">
    <div class="agent-control">
        <div class="agent-status">
            <div class="agent-avatar"><svg width="40" height="40" viewBox="0 0 40 40"><circle cx="20" cy="20" r="16" fill="none" stroke="#00ffc8" stroke-width="2"/><circle cx="20" cy="20" r="8" fill="none" stroke="#00ffc8" stroke-width="2"/><path d="M20 4 L20 8 M20 32 L20 36 M4 20 L8 20 M32 20 L36 20" stroke="#00ffc8" stroke-width="2"/><circle cx="14" cy="14" r="2" fill="#00ffc8"/><circle cx="26" cy="14" r="2" fill="#00ffc8"/><path d="M14 26 Q20 32, 26 26" stroke="#00ffc8" fill="none"/></svg></div>
            <div class="agent-name">SVG-3D AGENT</div>
            <div class="agent-state" id="agentState">üü¢ ACTIVE ‚Ä¢ PERCEPTION MODE</div>
            <div style="color:#88aaff; font-size:12px; margin-top:10px;" id="agentBrain">Processing environment...</div>
        </div>
        <div class="agent-toolbelt">
            <div class="tool-category"><h4>üîÆ PERCEPTION TOOLS</h4>
                <div class="tool-button" onclick="agent.useTool('scan-environment')"><span>üì°</span> Scan Environment</div>
                <div class="tool-button" onclick="agent.useTool('detect-objects')"><span>üéØ</span> Detect Objects</div>
                <div class="tool-button" onclick="agent.useTool('measure-distances')"><span>üìè</span> Measure Distances</div>
                <div class="tool-button" onclick="agent.useTool('analyze-spatial')"><span>üß†</span> Spatial Analysis</div>
                <div class="tool-button" onclick="agent.useTool('track-movement')"><span>üîÑ</span> Track Movement</div></div>
            <div class="tool-category"><h4>‚ö° MANIPULATION TOOLS</h4>
                <div class="tool-button" onclick="agent.useTool('transform-object')"><span>üîÑ</span> Transform Object</div>
                <div class="tool-button" onclick="agent.useTool('rotate-3d')"><span>üåÄ</span> Rotate 3D</div>
                <div class="tool-button" onclick="agent.useTool('scale-object')"><span>üìä</span> Scale Object</div>
                <div class="tool-button" onclick="agent.useTool('duplicate-object')"><span>üìã</span> Duplicate</div>
                <div class="tool-button" onclick="agent.useTool('align-objects')"><span>üéØ</span> Align Objects</div></div>
            <div class="tool-category"><h4>üß™ GENERATION TOOLS</h4>
                <div class="tool-button" onclick="agent.useTool('generate-cube')"><span>üì¶</span> Generate Cube</div>
                <div class="tool-button" onclick="agent.useTool('generate-sphere')"><span>‚ö™</span> Generate Sphere</div>
                <div class="tool-button" onclick="agent.useTool('generate-pattern')"><span>‚ú®</span> Generate Pattern</div>
                <div class="tool-button" onclick="agent.useTool('create-cluster')"><span>üåü</span> Create Cluster</div>
                <div class="tool-button" onclick="agent.useTool('liquid-morph')"><span>üíß</span> Liquid Morph</div></div>
            <div class="tool-category"><h4>ü§ñ REASONING TOOLS</h4>
                <div class="tool-button" onclick="agent.useTool('plan-path')"><span>üó∫Ô∏è</span> Plan Path</div>
                <div class="tool-button" onclick="agent.useTool('solve-spatial')"><span>üß©</span> Solve Spatial</div>
                <div class="tool-button" onclick="agent.useTool('optimize-scene')"><span>‚öôÔ∏è</span> Optimize Scene</div>
                <div class="tool-button" onclick="agent.useTool('predict-collision')"><span>‚ö†Ô∏è</span> Predict Collision</div>
                <div class="tool-button" onclick="agent.useTool('learn-pattern')"><span>üìö</span> Learn Pattern</div></div>
        </div>
    </div>

    <div class="viewport-3d">
        <svg id="svg3dCanvas" xmlns="http://www.w3.org/2000/svg"></svg>
        <div class="agent-overlay">
            <div class="perception-panel" id="perceptionPanel"><strong style="color:#00ffc8">üëÅÔ∏è PERCEPTION</strong><br><span id="perceptionText">Scanning environment...</span></div>
            <div class="reasoning-panel" id="reasoningPanel"><strong style="color:#ffaa00">üß† REASONING</strong><br><span id="reasoningText">Analyzing spatial relationships...</span></div>
        </div>
        <div class="action-log" id="actionLog"><div class="log-entry">ü§ñ Agent initialized ‚Ä¢ Ready for tasks</div></div>
    </div>

    <div class="agent-memory">
        <div class="memory-header"><h3 style="color:#00ffc8; letter-spacing: 2px;">üß† AGENT MEMORY</h3><span style="color:#00ffc8" id="memoryCount">0 memories</span></div>
        <div class="memory-graph" id="memoryGraph"></div>
    </div>

    <div class="agent-command">
        <div style="color:#00ffc8; font-weight:bold;">AGENT ></div>
        <input type="text" class="command-input" id="agentCommand" placeholder="Enter command or ask agent to perform a task..." onkeypress="if(event.key==='Enter') agent.processCommand(this.value)">
        <div class="agent-thinking" id="agentThinking"><span>STATUS</span><div class="dot-flashing"></div><div class="dot-flashing" style="animation-delay:0.2s"></div><div class="dot-flashing" style="animation-delay:0.4s"></div></div>
    </div>
</div>

<script>
class SVG3DEngine {
    constructor(svgId) {
        this.svg = document.getElementById(svgId);
        this.objects = new Map();
        this.camera = { x: 0, y: 0, z: -700 };
        this.time = 0;
    }

    createCube(id, position, color) {
        const s = 40;
        const vertices = [
            {x:-s,y:-s,z:-s},{x:s,y:-s,z:-s},{x:s,y:s,z:-s},{x:-s,y:s,z:-s},
            {x:-s,y:-s,z:s},{x:s,y:-s,z:s},{x:s,y:s,z:s},{x:-s,y:s,z:s}
        ];
        const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
        this.objects.set(id, { id, type: 'cube', position, rotation:{x:0,y:0,z:0}, scale:{x:1,y:1,z:1}, color, vertices, edges });
        this.render();
    }

    createSphere(id, position, color, radius = 30) {
        const vertices = [];
        for (let i = 0; i < 20; i++) {
            const theta = (i / 20) * Math.PI * 2;
            vertices.push({ x: Math.cos(theta) * radius, y: Math.sin(theta) * radius, z: 0 });
        }
        this.objects.set(id, { id, type: 'sphere', position, rotation:{x:0,y:0,z:0}, scale:{x:1,y:1,z:1}, color, vertices, edges: [] });
        this.render();
    }

    createDefaultScene() {
        this.createCube('cube_a', { x: -120, y: -40, z: 100 }, '#00ffc8');
        this.createCube('cube_b', { x: 120, y: 40, z: -40 }, '#66aaff');
        this.createSphere('sphere_a', { x: 0, y: 80, z: 0 }, '#ff66aa', 35);
    }

    project(v, obj) {
        const p = { x: v.x * obj.scale.x, y: v.y * obj.scale.y, z: v.z * obj.scale.z };
        const rx = obj.rotation.x * Math.PI / 180;
        const ry = obj.rotation.y * Math.PI / 180;
        const rz = obj.rotation.z * Math.PI / 180;

        let x = p.x, y = p.y, z = p.z;
        [y, z] = [y * Math.cos(rx) - z * Math.sin(rx), y * Math.sin(rx) + z * Math.cos(rx)];
        [x, z] = [x * Math.cos(ry) + z * Math.sin(ry), -x * Math.sin(ry) + z * Math.cos(ry)];
        [x, y] = [x * Math.cos(rz) - y * Math.sin(rz), x * Math.sin(rz) + y * Math.cos(rz)];

        x += obj.position.x; y += obj.position.y; z += obj.position.z;
        const fov = 500;
        const depth = (z - this.camera.z + fov);
        const scale = fov / Math.max(40, depth);
        return { x: 480 + x * scale, y: 360 + y * scale, visible: depth > 0 };
    }

    render() {
        this.svg.innerHTML = '';
        this.objects.forEach((obj) => {
            if (obj.type === 'cube') {
                obj.edges.forEach(([a, b]) => {
                    const p1 = this.project(obj.vertices[a], obj);
                    const p2 = this.project(obj.vertices[b], obj);
                    if (!p1.visible || !p2.visible) return;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
                    line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
                    line.setAttribute('stroke', obj.color); line.setAttribute('stroke-width', '2');
                    this.svg.appendChild(line);
                });
            } else {
                const p = this.project({ x: 0, y: 0, z: 0 }, obj);
                const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                c.setAttribute('cx', p.x); c.setAttribute('cy', p.y); c.setAttribute('r', Math.max(8, 28 * (500 / (obj.position.z - this.camera.z + 500))));
                c.setAttribute('fill', 'none'); c.setAttribute('stroke', obj.color); c.setAttribute('stroke-width', '2');
                this.svg.appendChild(c);
            }
        });
    }

    animate() {
        const loop = () => {
            this.time += 0.02;
            this.objects.forEach((obj) => {
                obj.rotation.y += 0.3;
                if (obj.liquid3D?.morphing) obj.position.y += Math.sin(this.time + obj.position.x * 0.01) * obj.liquid3D.intensity;
            });
            this.render();
            requestAnimationFrame(loop);
        };
        loop();
    }
}

class SVG3DAgent {
    constructor() {
        this.perception = { objects: new Map(), spatialMap: new Map(), distances: [], collisions: [], frame: 0 };
        this.memory = { shortTerm: [], working: [], longTerm: new Map(), episodic: [] };
        this.reasoning = { currentGoal: null, plans: [], decisions: [], confidence: 0.8 };
        this.tools = new Map();
        this.engine = null;
        this.initTools();
    }
    initTools() {
        this.tools.set('scan-environment', { name: 'Environment Scanner', execute: () => this.scanEnvironment() });
        this.tools.set('detect-objects', { name: 'Object Detection', execute: () => this.detectObjects() });
        this.tools.set('measure-distances', { name: 'Distance Measurement', execute: () => this.measureDistances() });
        this.tools.set('analyze-spatial', { name: 'Spatial Analysis', execute: () => this.analyzeSpatial() });
        this.tools.set('track-movement', { name: 'Movement Tracking', execute: () => this.trackMovement() });
        this.tools.set('transform-object', { name: 'Object Transformer', execute: (p) => this.transformObject(p) });
        this.tools.set('rotate-3d', { name: '3D Rotation', execute: (p) => this.rotate3D(p) });
        this.tools.set('scale-object', { name: 'Object Scaler', execute: (p) => this.scaleObject(p) });
        this.tools.set('duplicate-object', { name: 'Object Duplicator', execute: (p) => this.duplicateObject(p) });
        this.tools.set('align-objects', { name: 'Object Aligner', execute: (p) => this.alignObjects(p) });
        this.tools.set('generate-cube', { name: 'Cube Generator', execute: (p) => this.generateCube(p) });
        this.tools.set('generate-sphere', { name: 'Sphere Generator', execute: (p) => this.generateSphere(p) });
        this.tools.set('generate-pattern', { name: 'Pattern Generator', execute: (p) => this.generatePattern(p) });
        this.tools.set('create-cluster', { name: 'Cluster Creator', execute: (p) => this.createCluster(p) });
        this.tools.set('liquid-morph', { name: 'Liquid Morph', execute: (p) => this.liquidMorph(p) });
        this.tools.set('plan-path', { name: 'Path Planner', execute: (p) => this.planPath(p) });
        this.tools.set('solve-spatial', { name: 'Spatial Solver', execute: (p) => this.solveSpatial(p) });
        this.tools.set('optimize-scene', { name: 'Scene Optimizer', execute: () => this.optimizeScene() });
        this.tools.set('predict-collision', { name: 'Collision Predictor', execute: () => this.predictCollisions() });
        this.tools.set('learn-pattern', { name: 'Pattern Learner', execute: (p) => this.learnPattern(p || { pattern: 'default', data: {} }) });
    }

    connectEngine(engine) { this.engine = engine; this.log('Connected to SVG-3D Engine'); this.initializePerception(); }
    initializePerception() { setInterval(() => { if (this.engine) { this.perception.frame++; this.updatePerception(); } }, 200); }
    updatePerception() { this.detectObjects(); this.measureDistances(); this.updateSpatialMap(); this.predictCollisions(); this.updatePerceptionUI(); }
    detectObjects() {
        if (!this.engine) return [];
        const objects = [];
        this.engine.objects.forEach((object, id) => {
            objects.push({ id, type: object.type, position: { ...object.position }, rotation: { ...object.rotation }, scale: { ...object.scale }, color: object.color, vertices: object.vertices.length, depth: this.calculateDepth(object.position) });
            this.perception.objects.set(id, { ...object, id, lastSeen: this.perception.frame, confidence: 0.9 });
        });
        return objects.sort((a, b) => a.depth - b.depth);
    }
    calculateDepth(p) { return Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z); }
    updateSpatialMap() {
        this.perception.spatialMap.clear();
        this.perception.objects.forEach((o, id) => {
            const key = `${Math.round(o.position.x / 100)},${Math.round(o.position.y / 100)},${Math.round(o.position.z / 100)}`;
            if (!this.perception.spatialMap.has(key)) this.perception.spatialMap.set(key, []);
            this.perception.spatialMap.get(key).push(id);
        });
    }
    measureDistances() {
        const distances = [];
        const objects = Array.from(this.perception.objects.values());
        for (let i = 0; i < objects.length; i++) for (let j = i + 1; j < objects.length; j++) {
            const a = objects[i], b = objects[j];
            const d = Math.hypot(a.position.x - b.position.x, a.position.y - b.position.y, a.position.z - b.position.z);
            distances.push({ object1: a.id, object2: b.id, distance: d });
        }
        this.perception.distances = distances;
        return distances;
    }
    analyzeSpatial() {
        const analysis = { objectCount: this.perception.objects.size, clusters: this.findClusters() };
        this.memory.working.push({ type: 'spatial-analysis', timestamp: Date.now(), data: analysis });
        this.updateReasoning(`üìä Spatial analysis: ${analysis.objectCount} objects, ${analysis.clusters.length} clusters`);
        return analysis;
    }
    findClusters() {
        const clusters = [];
        this.perception.spatialMap.forEach((ids) => { if (ids.length > 1) clusters.push(ids); });
        return clusters;
    }
    trackMovement() { return []; }
    transformObject({ id, transformation = {} } = {}) { const o = this.engine?.objects.get(id); if (!o) return { success: false }; o.position = { ...o.position, ...(transformation.position || {}) }; this.engine.render(); return { success: true }; }
    rotate3D({ id, rotation = { y: 15 } } = {}) { const o = this.engine?.objects.get(id); if (!o) return { success: false }; o.rotation = { ...o.rotation, ...rotation }; this.engine.render(); return { success: true }; }
    scaleObject({ id, scale = { x: 1.2, y: 1.2, z: 1.2 } } = {}) { const o = this.engine?.objects.get(id); if (!o) return { success: false }; o.scale = { ...o.scale, ...scale }; this.engine.render(); return { success: true }; }
    duplicateObject({ id, offset = { x: 60, y: 0, z: 60 } } = {}) { const s = this.engine?.objects.get(id); if (!s) return { success: false }; const n = structuredClone(s); n.id = `${s.type}_${Date.now()}`; n.position = { x: s.position.x + offset.x, y: s.position.y + offset.y, z: s.position.z + offset.z }; this.engine.objects.set(n.id, n); this.engine.render(); return { success: true, newId: n.id }; }
    alignObjects({ ids = [], axis = 'x', value = 0 } = {}) { ids.forEach((id) => { const o = this.engine?.objects.get(id); if (o) o.position[axis] = value; }); this.engine?.render(); return { success: true }; }
    generateCube({ position = { x: 0, y: 0, z: 0 }, color = '#00ffc8' } = {}) { const id = `cube_${Date.now()}`; this.engine?.createCube(id, position, color); return { success: true, id }; }
    generateSphere({ position = { x: 0, y: 0, z: 0 }, color = '#ff66aa', radius = 30 } = {}) { const id = `sphere_${Date.now()}`; this.engine?.createSphere(id, position, color, radius); return { success: true, id }; }
    generatePattern({ type = 'grid', count = 9, spacing = 100 } = {}) {
        const ids = [];
        if (type === 'grid') {
            const n = Math.ceil(Math.sqrt(count));
            for (let r = 0; r < n && ids.length < count; r++) for (let c = 0; c < n && ids.length < count; c++) {
                const id = `pattern_${Date.now()}_${ids.length}`;
                this.engine?.createCube(id, { x: (c - n / 2) * spacing, y: (r - n / 2) * spacing, z: 0 }, `hsl(${ids.length * 33},100%,60%)`);
                ids.push(id);
            }
        }
        return { success: true, ids };
    }
    createCluster({ count = 8, radius = 200 } = {}) { const ids = []; for (let i = 0; i < count; i++) { const id = `cluster_${Date.now()}_${i}`; this.engine?.createSphere(id, { x: (Math.random() - .5) * radius, y: (Math.random() - .5) * radius, z: (Math.random() - .5) * radius }, `hsl(${Math.random() * 360},100%,60%)`, 18); ids.push(id); } return { success: true, ids }; }
    liquidMorph({ id, intensity = 0.7 } = {}) { const o = this.engine?.objects.get(id); if (!o) return { success: false }; o.liquid3D = { morphing: true, intensity }; return { success: true }; }
    planPath({ start = { x: 0, y: 0, z: 0 }, end = { x: 200, y: 120, z: 0 } } = {}) { const path = [start, end]; this.log(`üó∫Ô∏è Planned path with ${path.length} waypoints`); return { success: true, path }; }
    solveSpatial() { return { success: true, position: { x: 0, y: 0, z: 0 } }; }
    optimizeScene() { return { success: true, optimized: 0 }; }
    predictCollisions() { this.perception.collisions = this.perception.distances.filter(d => d.distance < 50); return this.perception.collisions; }
    learnPattern({ pattern, data }) { this.memory.longTerm.set(pattern, { data, timestamp: Date.now() }); return { success: true }; }
    processCommand(command = '') {
        this.log(`ü§ñ Processing: "${command}"`);
        const c = command.toLowerCase();
        if (c.includes('scan') || c.includes('analyze')) { this.useTool('scan-environment'); this.useTool('analyze-spatial'); }
        else if (c.includes('cube')) this.useTool('generate-cube', { position: { x: Math.random() * 400 - 200, y: Math.random() * 200 - 100, z: Math.random() * 300 - 150 } });
        else if (c.includes('sphere')) this.useTool('generate-sphere', { position: { x: Math.random() * 400 - 200, y: Math.random() * 200 - 100, z: Math.random() * 300 - 150 } });
        else if (c.includes('pattern')) this.useTool('generate-pattern', { count: 16 });
        else if (c.includes('cluster')) this.useTool('create-cluster', { count: 12 });
        document.getElementById('agentCommand').value = '';
    }
    useTool(toolName, params = {}) {
        const tool = this.tools.get(toolName); if (!tool) return null;
        this.log(`üîß Using: ${tool.name}`); document.getElementById('agentState').textContent = `‚öôÔ∏è PROCESSING ‚Ä¢ ${tool.name}`;
        const result = tool.execute(params);
        this.memory.shortTerm.push({ type: 'tool-use', tool: toolName, params, result, timestamp: Date.now() });
        this.updatePerceptionUI(); this.updateMemoryUI();
        setTimeout(() => document.getElementById('agentState').textContent = 'üü¢ ACTIVE ‚Ä¢ PERCEPTION MODE', 800);
        return result;
    }
    scanEnvironment() { const objects = this.detectObjects(); this.measureDistances(); this.updateReasoning(`üåç Environment scanned: ${objects.length} objects`); return { objects: objects.length, timestamp: Date.now() }; }
    updatePerceptionUI() { document.getElementById('perceptionText').textContent = `Objects: ${this.perception.objects.size} | Distances: ${this.perception.distances.length} | Collisions: ${this.perception.collisions.length}`; }
    updateReasoning(text) { document.getElementById('reasoningText').textContent = text; }
    updateMemoryUI() {
        const graph = document.getElementById('memoryGraph'); graph.innerHTML = '';
        this.memory.shortTerm.slice(-10).reverse().forEach((memory) => {
            const node = document.createElement('div'); node.className = 'memory-node';
            node.innerHTML = `<div class="memory-time">üïê ${new Date(memory.timestamp).toLocaleTimeString()}</div><div style="color:#00ffc8">${memory.type} ‚Ä¢ ${memory.tool || ''}</div><div style="color:#88aaff; font-size:11px; margin-top:5px;">${JSON.stringify(memory.params || memory.result || {}).slice(0, 80)}...</div>`;
            graph.appendChild(node);
        });
        document.getElementById('memoryCount').textContent = `${this.memory.shortTerm.length} memories`;
    }
    log(message) {
        const actionLog = document.getElementById('actionLog');
        const entry = document.createElement('div'); entry.className = 'log-entry';
        entry.textContent = `ü§ñ ${new Date().toLocaleTimeString()} - ${message}`;
        actionLog.appendChild(entry); actionLog.scrollTop = actionLog.scrollHeight;
        while (actionLog.children.length > 50) actionLog.removeChild(actionLog.children[0]);
    }
}

const engine = new SVG3DEngine('svg3dCanvas');
const agent = new SVG3DAgent();
window.engine = engine;
window.agent = agent;

document.addEventListener('DOMContentLoaded', () => {
    engine.createDefaultScene();
    engine.animate();
    agent.connectEngine(engine);
    setTimeout(() => { agent.useTool('scan-environment'); agent.useTool('analyze-spatial'); }, 500);
});
</script>
</body>
</html>
